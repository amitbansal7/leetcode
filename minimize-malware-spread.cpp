// Runtime: 164 ms
// Memory Usage: 27.8 MB
class Solution {
public:

  void _union(int x, int y, vector<int>&parent, vector<int>&rank) {
    int xp = find(x, parent);
    int yp = find(y, parent);

    //path compression
    if (rank[xp] > rank[yp]) {
      parent[yp] = xp;
    } else {
      parent[xp] = yp;
    }

    if (rank[x] == rank[y]) {
      rank[y]++;
    }
  }

  int find(int x, vector<int>&parent) {
    if (parent[x] != x) {
      parent[x] = find(parent[x], parent);
    }
    return parent[x];
  }

  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    vector<int> parent(n);
    vector<int> rank(n, 1);
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }

    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        if (graph[i][j]) _union(i, j, parent, rank);
      }
    }

    vector<int> malware(n, 0);
    vector<int> areaOfEveryParent(n, 0);

    for (int i = 0; i < n; i++) {
      areaOfEveryParent[find(i, parent)]++;
    }

    int index = INT_MAX;
    for (int a : initial) {
      malware[find(a, parent)]++;
      index = min(index, a);
    }

    int mx = 1;

    for (int i : initial) {
      int f = find(i, parent);
      if (malware[f] == 1) {
        if (mx < areaOfEveryParent[f]) {
          mx = areaOfEveryParent[f];
          index = i;
        }
        else if (mx == areaOfEveryParent[f]) {
          index = min(index, i);
        }
      }
    }

    return index;
  }
};